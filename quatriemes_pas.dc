%Dictionnaires, Applications & Fonctions
@HIDE.
%Il est possible de créer des dictionnaires en deltacode.
%Comme tout objet, il doit être déclarer comme suit :
%dict : T1 ⇴ T2.
%où T1 est le type des clès et T2 le type des valeurs.
%exemple :

dict : ϩ ⇴ ϩ.

% Ensuite, il faut lier les clés et les valeurs ensemble. Cela ce fait de la manière suivante :

dict$"nom de famille" ≔ "Dupont".
dict$"prénom" ≔ "Charles".

%Ensuite pour récupérer les valeurs, il faut appeler le dictionnaire ainsi :

dict$"prénom".

%Par exemple si vous souhaitez faire un dictionnaire qui va associer à chaque lettre sa position dans l'alphabet, on fait:

∃ i ∊ ℕ.
∃ ch ∊ ϩ.
i ≔ 1.
ch ≔ "abcdefghijklmnopqrstuvwxyz".

alphabet : ℕ ⇴ ϩ.
∀ car ∊ ch : \
alphabet$i ≔ car.
i ≔ i+1.
/.

%Regardons maintenant l'utilisation des applications.
%Les applications sont des sortes de fonctions.
%Cependant, elles n'ont accès qu'à elle-même et aux arguments.
%Elles sont des applications au sens mathématique du terme.
%exemple :

f : ℝ ⟶ ℝ.
f : x ⟼ x+1.

%On vient par exemple de définir la fonction de ℝ dans ℝ qui à x associe x+1

%On peut faire d'autres choses comme des fonctions récursives :

factorielle : ℕ ⟶ ℕ.
factorielle : n ⟼ ➣ n = 0 : 1 ➣ ⊤ : n × factorielle⟨n-1⟩.

%On notera que l'utilisation des structures conditionnelles se font légèrement différemment.
%Lorsque l'on souhaite les appeler, on procède ainsi :

∃ k ∊ ℕ. %simple test
∃ x ∊ ℝ. %idem
@SHOW. %idem
x ≔ f⟨2⟩. % Notez bien que l'on n'aurais pas pu utiliser k à la place de x car f renvoie un ℝ alors que k est dans ℕ.
k ≔ factorielle⟨0⟩.
k ≔ factorielle⟨5⟩.

%Regardons maintenant les fonctions...
%On crée une fonction dans un bloc délimité par des #.
%On peut par exemple refaire notre application f sous forme de fonction :
#
g : ℝ ⟶ ℝ. %Nom de la fonction
⟨x⟩. %nom des arguments
"Fonction qui a x associe x+1". % On peut rajouter une docstring pour clarifier le fonctionnement d'une fonction
%corps de la fonction
⟼ x +1.
#
x ≔ g$x.

%On peut accéder aux variables globales dans une fonction
%par exemple :
#
h : ℘(∅) ⟶ ℘(∅).
⟨⟩.
echo$k.
#

h$. %ça fonctionne !

%Cependant si on considère :
#
fct : ℘(∅) ⟶ ℘(∅).
⟨⟩.
k ≔ 5.
#


fct$.
echo$k.
%On remarque que k n'a pas changé de valeur de manière globale. 
%Si on veut que k change de valeur de manière globale, il faut rajouter @GLOBAL dans la signature de la fonction :

#
fct₂ : ℘(∅) ⟶ ℘(∅).
⟨⟩.
@GLOBAL.
k ≔ 5.
#

fct₂$.
echo$k.
%La valeur de k a bien été modifiée.

%Il est possible de créer des fonctions "restreintes". C'est à dire qu'elles ne peuvent pas être appelées directement par l'utilisateur. Elles peuvent cependant être appelées par une autre fonction.
#
fonction₁ : ℘(∅) ⟶ ℘(∅).
⟨⟩.
@RESTRICT.
∃ j ∊ ℝ.
j ≔ 5.
echo$j.
#

%fonction₁$.%essayez pour voir...

#
fonction₂ : ℘(∅) ⟶ ℘(∅).
⟨⟩.
fonction₁$.
#

fonction₂$.

%lorsqu'on crée une fonction on peut évidemment les déclarer comme ayant des effets globaux, étant restreintes et ayant une doc-string.
%cependant il faut respecter cet ordre dans la signature de la fonction.

